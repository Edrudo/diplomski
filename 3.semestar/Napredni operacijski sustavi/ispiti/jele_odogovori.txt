Pitanja za vježbu 1
    1. Kako se iz programa koriste naprave? Zašto baš tako?

          Iz perspektive operacijskog sustava (OS-a) upravljanje napravama obavlja se preko upravljackih sklopova na koje su naprave spojene.
          Naprave se iz programa koriste kroz usluge operacijskog sustava.
          OS upravlja napravama: inicijalizira ih, zna kako ih koristiti (preko "upravljaˇckih programa"),
          dozvoljava njihovo korištenje kroz funkcije koje OS nudi, rješava probleme "paralelnog korištenja" od strane više programa


    2. Koje operacije OS nudi (preko sucelja) za korištenje naprava? Koje su osnovne, a koje dodatne?

          Osnovne: otvori, citaj/piši, zatvori. Dodatne operacije omogucuju odabir tražene informacije (pomak),
          upravljanje s više naprava odjednom (cekanje/provjera da se bar negdje nešto dogodi),
          stvaranje posebnih datoteka u datotecnom sustavu koje su povezane s napravama, postavljanje posebnih svojstava takvim datotekama te
          slanje naredbi upravljackom programu naprava.

    3. Što su to asinkrone operacije s napravama?

          Ideja: pokreni operaciju, ali ne cekaj njen kraj. Nekoliko nacina da se ceka/dozna za kraj operacije: cekaj dodatnim pozivom,
          provjeravaj status, primitak signala.

    4. Navedite nekoliko mogucih podjela naprava ovisno o svojstvima, nacinu spajanja, nacinu komunikacije, smjeru podataka, ...

          fizicke dimenzije, nacine spajanja na/u racunalu, brzina rada, smjer podataka: ulazna, izlazna, ulazno-izlazna,
          dohvat podataka: znak po znak ili blokovi podatak (npr. sektor, paket), citanje je slijedno ili je moguc dohvat bilo kojeg podatka,
          sinkrono ili asinkrono (ˇceka se na završetak operacije ili ne), može li se naprava istovremeno koristiti od strane više dretvi ili ne

Pitanja za vježbu 2

    1. Ako zanemarimo nacin spajanja naprave, koji su osnovni nacini upravljanja napravama (posluživanja naprava)?
          radno cekanje – petlja u kojoj se ceka da naprava bude spremna,
          prekidi – naprava javlja kad je spremna,
          izravan pristup spremniku - naprava sama prenosi podatke u radni spremnik,

    2. Opisati osnovna nacela upravljanja radnim cekanjem, prekidima te korištenjem sklopova s izravnim pristupom spremniku (DMA).
        radno cekanje – petlja u kojoj se ceka da naprava bude spremna
        prekidi - obrada prekida se programira preko zasebne tablice – IDT (interrupt description table)
                - Kad se dogodi prekid, uz prekid dolazi i informacija o uzroku – broj prekida → N
                - Broj prekida se koristi kao indeks za IDT, uzima se N-ti redak i tamo piše koju funkciju
                  treba pozvati za obradu tog prekida
                - izvori prekida – prosljedivanje prekida do procesora (prima i prosljeduje “lokalne” prekide procesoru) od strane naprave
        izravan pristup spremniku - OS izravno koristi pristupni sklop, osim u posebnim slucajevima kao što su datotecni podsustav i mrežni podsustav

    3. U jednostavnom modelu jezgre ulazno-izlazne operacije može se pretpostaviti da naprava obavlja zadane joj naredbe slijedno.
       Stoga bi procesi koji su tražili takve operacije mogli biti u jedno uredenom redu, cekajuci dovršetke svojih operacija.
       Koji su problemi ovog modela zbog specificnosti stvarnih sustava? Kako se u stvarnim sustavima rješavaju takvi problemi?

        Problem je sto zahtjev tako može i duže ostati u sustavu, tražiti i složenije operacije nad napravama.
        Naprave možda ne moraju posluživati zahtjeve po redu prispijeca. Operacija tražena od procesa može zahtijevati više UI operacija, možda i s više naprava.

        Stvarni sustavi: tek kad je zahtjev gotov (odraden do kraja od strane naprave i jezgre), dretva koja je tražila operaciju može nastaviti s radom.
        Zahtjev tako može i duže ostati u sustavu, tražiti i složenije operacije nad napravama.

        Stvarni sustavi su znacajno složeniji, i u sklopovlju i programskoj potpori. Složenost se u stvarnim sustavima “rješava” podjelom na podsustave i slojeve.

    4. Kako se rješava problem složenosti ostvarenja operacijskog sustava u stvarnim sustavima, npr. Linuxu?
        Složenost se u stvarnim sustavima “rješava” podjelom na podsustave i slojeve.

Pitanja za vježbu 3

    1. Kako se može pristupiti napravama, tj. njihovim upravljackim sklopovima?
        Napravama se najcešce može pristupiti korištenjem adresa. Adrese mogu biti prave ili virtualne.
        Adrese koje se koriste za komunikaciju s napravama su cesto mapirane u adresni prostor upravljackog sklopa - kontrolera na koji je naprava spojena.
        Ako OS koristi stranicenje onda te adrese treba mapirati u tablici prevodenja.

    2. Zašto su stvarne arhitekture racunala hijerarhijski gradene, s premosnicima izmedu razlicitih dijelova (sabirnica)?
        Ideja je da se sporije naprave stave na sporije sabirnice, da ne utjecu na performanse brzih naprava
        (koje bi inace morale cekati duge sabirnicke cikluse sporijih naprava)

    3. Nekim se napravama pristupa korištenjem adresa. Koji sve problemi zbog toga mogu nastati, tj. što treba “reci procesoru” u tom slucaju?
        Da se nešto ne optimira: - prirucni spremnik procesora - treba upisati u napravu, ne samo u prirucni spremnik
                                                               - bitno kad je redoslijed upisivanja bitan
                                 - optimiranje izmjenom redoslijeda izvodenja susjednih nezavisnih instrukcija
                                                               - ako se takvim instrukcijama upisuje u mapirane registre naprave takve promjene
                                                                 redoslijeda mogu biti problem
                                 - da se izbjegnu ovakvi problemi ubacuju se posebne instrukcije

    4. Zašto se koriste meduspremnici? Koju funkcionalnost obavljaju?
        Meduspremnici se koriste radi povecanja ucinkovitosti. Oni koji ih koriste mogu raditi raznim brzinama.
        Meduspremnik dozvoljava “gomilanje” podataka i “praznog” prostora.
        Ponekad tek skup podataka cini cjelinu koji ima smisla prenositi. Mnoge naprave su optimirane za blokovski prijenos podataka (kao i pristup memoriji).
        Za ulazno/izlazne naprave meduspremnik može biti podijeljen na dva dijela: za ulazne i za izlazne podatke.

    5. Navesti vrste meduspremnika i opisati kako se oni koriste.
        1. Meduspremnik za jedan podatak – u njega stane samo jedan podatak (bajt, paket, blok).
        2. Dvostruki meduspremnik (engl. double buffer) - u prvi se piše dok se iz drugog cita, uz zamjenu uloga kad se citanje/pisanje obavi
                                                     - ulazna naprava piše u prvi, a OS može ˇcitati iz drugog meduspremnika
        3. Kružno korištenje meduspremnika - proširenje koncepta dvostrukog meduspremnika na N meduspremnika
                                           - kad se jedno mjesto u meduspremniku popuni, iduci podatak stavlja se na iduce

    6. Usporediti meduspremnik (engl. buffer) i prirucni spremnik (engl. cache).
        Meduspremnik (engl. buffer) - Pojam meduspremnik se obicno odnosi na spremnik koji se koristi za prijenos podataka
                                      izmedu dviju strana, npr. naprave i operacijskog sustava.
                                    - Pri prijenosu se podaci micu s one strane koja ih je kopirala u meduspremnik
                                    - Podaci su samo na jednom mjestu (nema kopija podataka)
        Prirucni spremnik (engl. cache) - Prirucni spremnik se koristi za ubrzanje rada
                                        - Kopija podataka (i instrukcija) se dohvaca da bude bliže onome tko ih koristi (procesor, naprava)
                                        - Postoji više kopija podataka

        Kod brzih naprava treba razmisliti o nacinu korištenja meduspremnika.
        Pretjerano kopiranje podataka može usporiti operacije koje trebaju biti brze.

Pitanja za vježbu 4

    1. Navesti osnovna svojstva komunikacije preko serijske veze (npr. RS232).
        U jednom smjeru bitovi se prenose preko jedne linije (žice). Jedinica podataka je znak (5–8 bita) – grupa uzastopnih bitova.
        Potrebno je sinkronizirati pocetak/kraj (start/stop bit). Bitove jednog znaka moguce je zaštititi paritetnim bitom (ali se to ne mora koristiti).
        Veca grupa podataka – znakova se šalje slijedno, znak po znak.

    2. Navesti osnovna svojstva komunikacije preko paralelne veze.
        Bitovi koji cine jednu informaciju (npr. jedan znak) se šalju paralelno preko više linija.
        Ideja je da se u jednom ciklusu signala prenese više bitova.
        Previše sinkronizacije ogranicava brzinu prijenosa na vécim udaljenostima.
        Zato se danas sve više koristi serijska veza, osim na vrlo brzim sabirnicama, npr. procesor – memorija; ali je zato memorija jako blizu procesora.

    3. Navesti nekoliko protokola koji koriste serijsku i nekoliko koji koriste paralelnu vezu.
        Serijska: serijska veza (RS-232) se koristila za komunikaciju s modemom, DTE – data terminal equipment
        Paralelna: LPT: paralelni port DB-25

    4. Usporediti serijsku i paralelnu komunikaciju. Koje su prednosti serijske?
        Skuzi iz proslih odgovora.

    5. Opisati kako su USB naprave spojene u racunalu: logicki, fizicki.
        Sabirnica povezuje naprave na racunalo. Sabirnica je upravljana s jednog, glavnog/upravljackog cvora – u nastavku upravljac.
        Upravljac zapocinje svaku razmjenu poruka: komunikacija se uvijek odvija samo izmedu upravljaca i neke naprave.
        Logicki, sve su naprave na zajednickoj sabirnici. Pri slanju podataka od naprave prema upravljacu koristi se samo jedna staza.
        Svaka naprava dobiva (nakon spajanja) adresu: 7-bitovni broj.

    6. Opisati osnovni nacin rada (komunikacije) naprave koja je spojena na USB prikljucak.
        Svaka naprava dobiva (nakon spajanja) adresu: 7-bitovni broj.
        Na jedan upravljac ukupno može biti spojeno 127 naprava.
        Upravljac svaku napravu periodicki proziva – pita ju ima li nešto za javiti, podatke ili status.
        Svaka transakcija se sastoji nekoliko paketa, ovisno o tipu transakcije.
        Svaki se paket (na fizickoj razini) sastoji od tri dijela:
            1. sinkronizacijskog zaglavlja (SZ, sync)
            2. tijela paketa (paket podatkovne razine)
            3. oznake kraja paketa (KP, End-of-Packet:EOP)
        Tip paketa odreden je prvim bajtom paketa (prvi bajt nakon SZ) – PID – identifikator paketa:
            1. TOKEN paketi (IN, OUT, SETUP, PING, Start-of-frame:SOF – oznaka pocetka okvira PO)
            2. paketi za prijenos podataka (DATA0/1/2, cirkularno)
            3. paketi za sinkronizaciju (handshake, ACK, NAK, . . . )


    7. Što su to okviri, transakcije, paketi u kontektstu protokola USB?
        Komunikacija je podijeljena u okvire (engl. frame). Svaki okvir se sastoji od oznake
        pocetka okvira PO (engl. Start of Frame – SOF) te jedne ili više transakcija.
        Svaka transakcija se sastoji nekoliko paketa, ovisno o tipu transakcije.
        Svaki se paket (na fiziˇckoj razini) sastoji od tri dijela:
            1. sinkronizacijskog zaglavlja (SZ, sync)
            2. tijela paketa (paket podatkovne razine)
            3. oznake kraja paketa (KP, End-of-Packet:EOP)


    8. Što je to adresa naprave, a što adresa funkcije naprave (kod protokola USB)?
        Adresa naprave se sastoji od same adrese naprave (7-bitovne adrese) te od broja funkcije naprave (engl. end-point).
        Naprava može imati više “funkcija”. Svaka funkcija (engl. endpoint) ima svoj redni broj (poˇcevši s nulom), koji je dodijeljen pri inicijalizaciji naprave.
        Veza upravljac–naprava je zapravo veza upravljac–funkcija.
        Funkcije mogu biti grupirane u sucelja(engl.interface) koje definirane neku operaciju naprave

    9. Za prijenos podataka USB-om preko protoka (engl. stream) koriste se cjevovodi: izokroni, prekidni i veliki. Opisati njihova svojstva i namjenu.
        Dva tipa cjevovoda:
            1. cjevovod za razmjenu poruka (dvosmjerni)
            2. cjevovod za protok podataka (jednosmjerni)
                a) Izokroni prijenosi (engl. Isochronous) – garantira se propusnost, ali s mogucim gubicima podataka
                b) Prekidni prijenosi – za brze odgovore na dogadaje
                c) Veliki prijenosi (engl. Bulk transfers) – za prijenos vece kolicine podataka
                    – ne garantiraju se ni propusnost ni kašnjenja – koriste se slobodni ciklusi na sabirnici

    10. Zašto za mnoge USB naprave nije potrebno instalirati upravljacke programe, véc ih operacijski sustav može koristiti s postoje cim?
        USB definira nekoliko tipova naprava – klasa naprava, korištenjem 8-bitovnog koda
        Ideja je da posebni upravljacki programi nisu potrebni za napravu koja spada u neku kategoriju.
        Da se za nju mogu koristiti uobicajeni upravljacki programi za takvu klasu naprave (koje OS vec ima).

    11. Kako se prenose podaci preko PCIe? Koliko vodica se koristi, je li moguc istovremeni prijenos u oba smjera?
        Izravna komunikacija izmedu dviju strana (npr. naprave i PCIe kontrolera). Moguca istovremena dvosmjerna komunikacija i
        serijska komunikacija po pojedinim stazama. Svaka veza (engl. link) izmed ̄u dviju naprava povezanih preko PCIe se sastoji od jedne ili
        više staza. Dvosmjerna komunikacija na svakoj stazi. Za svaki smjer dva vodica, ukupno cetiri vodica za svaku stazu (lane).

    12. Kako se prenose podaci u/iz memorije PCIe naprave?
        Paketi se salju  na fizickoj, podatkovnoj i transakcijskoj razini.
        Svaki paket se potvrduje s ACK ili NAK porukama (paketima) ako je bilo grešaka u prijenosu.
        Da ne bi došlo do zagušenja, naprava javlja stanje svog meduspremnika – "kredit". Ona druga strana treba paziti da ne pošalje više od toga.
        Kad se u meduspremniku oslobodi nešto mjesta ponovno se šalje osvježena vrijednost kredita.

    13. Usporediti PCI i PCIe. Koje su prednosti sabirnice PCIe?
        Nezz
    14. Koja je jedinica podataka (ne upravljackih naredbi) koja se prenosi preko SATA protokola? Zašto nije proizvoljna velicina podataka?
        Serijski prijenos bit-po-bit. Jedinica podataka blok (sektor). Pretpostavljam da je isti razlog kao gore, da nebi doslo do zagusenja medusoremnika???

Pitanja za vježbu 5
    1. Unutar jezgre kod se može izvoditi u “razlicitim kontekstima”. Koji su to i koja ogranicenja postavljaju pojedini konteksti?
        Jezgrin kod se može izvoditi u tri “okoline”:
            1. u jezgrinom kontekstu procesa (kad proces poziva jezgrinu funkciju)
                -  kada se jezgrina funkcija zove iz programa, npr. read() tada se pri ulasku u jezgru prelazi u jezgrin kontekst procesa
                - umjesto dretve koja se izvodila u korisnickom nacinu rada, sada se aktivira jezgrina dretva koja izvodi jezgrinu funkciju.
                  Ta dretva je “produžetak” korisnicke (ali sada u jezgri).
                - jezgrina dretva može se i blokirati posebnim “unutarnjim” mehanizmima, sliˇcnima “vanjskim” (semafori, monitori, ...)
            2. u kontekstu jezgrine dretve (jezgrin proces)
                - pri prihvatu zahtjeva zapocinje obrada prekida
                -  “obrada” koja je ovako zapocela ne smije u svom kodu imati blokirajuce pozive
                - ako je potrebno više vremena za obradu, onda se posao obrade dijeli na dva dijela:
                    1. neophodni dio – “top half”
                    2. dodatni dio – “bottom half” - obavlja se naknadno, s dozvoljenim prekidanjem
            3. bez konteksta dretve – “atomarno” (obrada prekida, alarmi, taskler, softirq)

    2. Što treba napraviti/koristiti ako u jezgrinoj funkciji treba pristupiti adresnom prostoru procesa?
        Pristup adresnom prostoru procesa:
            – samo ako se j.f. pozvala iz procesa
            – dohvat/pohrana podataka iz/u proces posebnim funkcijama

    3. Obrada prekida naprave vrlo je bitan dio upravljanja napravom, ali može bitno utjecati i na svojstva sustava.
       Zbog cega? Koje mogucnosti u Linuxu stoje na raspolaganju za obradu prekida? Koja su njihova svojstva / kada ih koristiti?
        Preduga obrada prekida blokira jezgru od obrade ostalih prekida koji dolaze. U linuxu postoji ova opcija da se obrada prekida podijeli na
        top half i bottom half. Odgovaraju ́cim suceljem se unutar obrade prekida (top half) stvori/pripremi posao koji
        ce se na jedan od navedenih nacina odraditi kasnije, nakon završetak ove obrade.

    4. Što se smije a što ne koristiti u jezgri? Je li to ovisi o kontekstu u kojem se izvodi kod jezgre? Kako?
        1. atomaran kod (obrada prekida=top half, tasklet, softirq, alarmi)
            – nikakve funkcije koje mogu blokirati
            – nikakve funkcije koje traže kontekst dretve (npr. semafori, monitori) – mogu funkcije s radnim cekanjem: spinlock
        2. kod s kontekstom (u kontekstu procesa, workqueue, threaded IRQ) – sve funkcije (interne jezgrine)\

    5. Što je to modul u kontekstu jezgre Linuxa? Cemu služi?
        - upravljacki program može biti na dva nacina ukljucen u jezgru Linuxa:
            1. permanentno (staticki)
            2. dinamicki kao modul
        - upravljacki program može biti pripremljen zajedno s cijelom jezgrom Linuxa ili pripremljen kao “modul” koji se po potrebi,
          dinamicki ucitava u jezgru te mice kada više nije potreban

    6. Navesti tri osnovne klase naprava u Linuxu.
        • tri su osnovne klase naprava (stvarnih i virtualnih) u Linuxu
            1. znakovne naprave – character devices
                – naprave koje daju/primaju niz bajtova; npr. tipkovnica, miš, terminal, pisac
            2. blokovske naprave – block devices
                – naprave kojima je jedinica podataka blok; najcešce naprave koje ostvaruju datotecne sustave
            3. mrežna sucelja – network devices
                – naprave kojima je svrha ostvarenje komunikacije (koriste se iz mrežnog podsustava)

    7. Koja je zadaca upravljackog programa naprave?
        Upravljacki programi upravljaju stvarnim ili virtualnim napravama. On registrira svoje funkcije za neke dogadaje.
        Uobicajene takve funkcije su: otvari, zatvori, citaj, piši, pomakni, asinkrono citaj/piši, šalji upravljacke naredbe, mapiraj memoriju, zakljucaj,...

    8. Koja su uobicajena sucelja koja znakovna naprava mora ostvariti, a da bi se uklopila u Linux?
        do_syscall ⇒ sys_write ⇒ ksys_write ⇒ vfs_write ⇒ shofer_write
        Ne znam jel mislio na ovo i boli me.

Pitanja za vjezbu 6

    1. Koji su sve koraci potrebni za ostvarenje naprave da bi se ona mogla koristiti iz pro- grama?
        1. Identificirati napravu - dati joj glavni i pomocni broj
        2. Registrirati napravu i njene operacije => struct cdev koja sadrzi struct file_operations
        3. Naredbom mknod u ljusci treba dodati napravu u datotecni sustav, nakon cega se naprava moze otvoriti i koristiti kao datoteka

    2. Zašto se u ostvarenju kružna meduspremnika u linux/kfifo.h koriste meduspremnici cija je velicina potencija broja dva?
        Radi izbjegavanja operacija dijeljenja, a i takve su velicine spremnika uobicajene u jezgri

    3. Može li se u operaciji write koju ostvaruje naprava koristiti mutex_lock? Obrazložiti zašto da/ne.
        Moze, mutex_lock u write operaciji omogucava da sinkronizaciju dretvi koje zele pristupiti zajednickom spreminiku ili driveru naprave.

    4. Koje su prednosti korištenja makroa za ostvarenje operacija zapisa u dnevnik (LOG vs printk)?
        Ispisuje se broj linije s koje dolazi ispis, dodaje se ime modula. Posto je ispis potreban samo pri debugiranju, moguce je pretprocesorskim direktivama upravljati
        ponasanjem makroa, tj. ispisuje li se nesto ili ne.

    5. Neka struktura nešto ima element element. Ako u varijabli x imamo adresu dijela element nekog objekta, kako doci do adrese objekta koji je tipa nešto? Pokazati kodom.
        wtf

    6. Koje su prednosti korištenja liste preko postojeceg sucelja, npr.preko sucelja linux/list.h?
        Lista je dvostruko povezana, njoj se pristupa funkcijama. Sucelje vraca kazaljku na prvi element liste a ne objekt.

    7. Što se nalazi u varijabli jiffies? Za što se ona koristi?
        Vecina internih jezgrinih funkcija koristi vrijeme preko broja otkucaja sata koji se ažuriraju kroz varijablu jiffies
    8. Opisati nacin korištenja mehanizma reda poslova (workqueues).
        Koriste se za rasporedivanje poslova u dodatnom dijelu obrade prekida (top-half). Poslovi u istom redu se izvode jedan za drugim!
        Stoga je potrebno paziti “što se radi” u pojedinom poslu, jer odgoda u nekom poslu ne odgad ̄a samo njega ve ́c i sve ostale u tom redu.


    9. Opisati sinkronizaciju preko mehanizma dogadaja (events).
        Prvo treba definirati i inicijalizirati red za blokirane dretve. Zatim treba cekati dogadaj ispunjenja uvjeta sa wait_event.

    10. Opisati sinkronizaciju preko mehanizma završetaka (completions).
        Završeci (engl. completion) su mehanizmi sinkronizacije koji omogucuju da jedna strana (dretva) bude blokirana na upitu o završetku necega,
        što neka druga strana dojavljuje. Cekanje da nešto bude gotovo: wait_for_completion(&cmpl).

    11. Koje se od navedenih funkcija smiju koristiti u atomarnim kontekstima: mutex_lock , mutex_unlock, wait_event, wake_up, wait_for_completion, complete, spin_lock, spin_unlock.
        Spinlock, wait_event, wake_up. Dakle fje koje ne blokiraju ili traze kontekst dretve. Mogu funkcije s radnim cekanjem.

    12. Cemu služi sucelja request_irq i request_threaded_irq? Kako se ona medusobno razlikuju?
        request_irq - registriranje funkcije koja ce obraditi neki prekid. Ukoliko ce obrada tog prekida trajati duze vrijeme preporuka je u toj funkciji napraviti samo neophodni dio posla (top half),
        a ostatak (bottom half) delegirati nekom drugom mehanizmu.

        request_threaded_irq - ukoliko je unaprijed poznati da ce taj dodatni dio trebati, moze se koristiti ovo sucelje koje stvara dretvu koja ce odraditi taj dodatni posao.

    13. Tko i kad vraca vrijednosti IRQ_HANDLED, IRQ_WAKE_THREAD?
        IRQ_HANDLED - vraca funkcija koja obraduje prekid, i to kada se taj prekid obradi do kraja

        IRQ_WAKE_THREAD - ovu vrijednost vraca funkcija koja obraduje prekid u slucaju kada se korisiti request_threaded_irq. Nakon toga se aktivira i prekidna dretva koja izvodi funkciju.
                           ova vrijednost se ne vraca ukoliko nema toga dodatnog posla.

    14. Opisati cemu služi sucelje poll (za programe, ne jezgru). Što se njime može postici?
        Ceka da se nesto dogodi nad skupom otvorenih "datoteka". Datoteka moze biti i neka naprava.

    15. Opisati cemu služi sucelje ioctl (za programe, ne jezgru). Što se njime može postici?
        Korisnicki programi pomocu ioctl mogu slati naredbe i zahtjeve "izravno" upravljackim programima. Ti zahtjevi i naredbe su kompleksniji te se oni ne mogu ostvariti samo pozivom funkcije write.

****7. Svojstva višeprocesorskih sustava****

	
1. Zašto su višeprocesorski sustavi danas svugdje?
	Zato što današnja tehnologija ne omogućava efikasno korištenje veće frekvencije na jednom procesoru (a da se ne troši jako puno energije na hlađenje)
2. Navesti osnovne vrste višeprocesorskih sustava i gdje se one koriste
	1. Simetrični višeprocesorski sustavi
		- svaki procesor je zaseban čip i ima svoj priručni spremnik
		- stariji višeprocesorski sustavi spadaju u ovu kategoriju
	2. Višejezgreni procesori
		- jedan čip s više procesorskih jedinki – jezgri (priručni spremnik podijeljen na razine)
 		- zajednička memorija odvojena
		- većina današnjih sustava spada u ovu kategoriju
	3. Simetrični višeprocesorski sustavi s višejezgrenim procesorima
		- simetrični višeprocesorski sustavi kod kojih je svaki procesor višejezgreni
		- uglavnom na poslužiteljima
	4. raspodijeljeni višeprocesorski sustavi
		- više procesorskih kartica, na svakoj više procesora i lokalna memorija
		- odvojena zajednička memorija
		- NUMA sustavi
		- kod jačih poslužitelja
3. Navesti prednosti i nedostatke simetričnih i asimetričnih višeprocesorskih sustava.
		?
4. Zbog kojih svojstava današnje sustave možemo nazivati i nehomogenim višeprocesorskim sustavima?
	Jer koriste brze i spore jezgre zbog uštede energije??
5. Što je to sklopovska višedretvenost (npr. hyperthreading)?
	To je višedretvenost u kojoj se kada čekamo da određena dretva čeka druga dretva izvršava svoje instrukcije kako ne bismo gubili vrijeme


****8. Problemi pri ostvarenju operacijskog sustava za višeprocesorske sustave****


1. Navesti načine za očuvanje konzistentnosti strukture podataka jezgre u višeprocesorskom sustavu
	1.	zaključavanja
	2.	atomarne operacije
	3.	oprezno korištenje
2. Koje dvije osnovne vrste zaključavanja postoje? Koja su njihova dobra i loša svojstva?
	1.	blokirajuće - dretva se zaustavlja i miče u stranu, ako se jezgrina funkcija izvodi u kontekstu neke (jezgrine) dretve
		a.	dobro je što se ne dohvaća stalno vrijednost koja se provjerava
		b.	loše je što se prilikom micanja u stranu moraju obaviti razni poslovi (spremanje konteksta, promjena dretve i prateće operacije s priručnim spremnikom)
	2.	radno čekanje - dretva u petlji provjerava neki uvjet dok se ne ispuni (i troši procesorsko vrijeme), tj. dok ga neka druga dretva na nekom drugom procesoru ispuni (koja paralelno radi) - radno čekanje je efikasno samo ako se zaključavaju kratki dijelovi koda
		a.	dobro je što se ne moraju obavljati poslovi micanja u stranu
		b.	loše djelovanje na priručni spremnik zbog stalnog dohvaćanja i provjeravanja jedne vrijednosti
3. Kada ima smisla koristiti atomarne operacije?
	za kratke operacije možda se zaključavanje može izbjeći korištenjem atomarnih operacija
4. Zašto samo korištenje atomarnih operacija ponekad nije dovoljno?
	?
5. Koja od navedenih “razina atomarnosti” je najzahtjevnija pri radu: a) je točno
	a) konzistencija nad slijedom operacija (total ordering)
	b) konzistencija nad jednom operacijom (relaksirana)
	c) konzistencija nad povezanim varijablama (acquire/release) 
	d) konzistencija nad nepovezanim varijablama (acquire/consume)?
6. Zašto ponekad i samo spremanje/čitanje jedne varijable može biti problem (zašto se koriste READ_ONCE i WRITE_ONCE)?
	Zato što ako ne koristimo atomarne operacije onda prevoditelj ima “punu slobodu” nad optimiranjem koda i svašta se još može dogoditi što u paralelnom radu može prouzrokovati neočekivane probleme. npr. ponekad spremanje i samo jedne vrijednosti (ili ˇčitanje) može biti odgođeno ili čak i razlomljeno na više sabirničkih ciklusa
7. Zašto se za “red pripravnih dretvi” na višeprocesorskom operacijskom sustavu zapravo koristi više redova, po jedan za svaki procesor?
	– osnovni razlog za to je korištenje priručnog spremnika procesora
	- ideja je da dretve koje se izvode na tom procesoru, iako se povremeno ne izvode (zbog drugih dretvi na tom procesoru) ipak će pri povratku izvođenja u tom priručnom spremniku naći neke svoje podatke koje neće trebati ponovno dohvaćati iz radnog spremnika – tako se povećavaju performanse


****9. Raspoređivanje dretvi u višeprocesorskim sustavima****


1. Koji se kriterij raspoređivanja najčešće koristi za vremenski kritične dretve (SCHED_FIFO, SCHED_RR) a koji kriterij za nekritične (obične, SCHED_OTHER)?
	U linuxu se koristi SCHED_DEADLINE za kritične.??
	MFQ se koristi za nekritične??
2. Zašto se za svaki procesor stvara zasebni red pripravnih dretvi?
	– zbog performansi – boljem korištenju priručnog spremnika (“hot cache”)
3. Kada se koristi guranje a kada povlačenje dretvi kod raspoređivanja kritičnih dretvi?
	Kad neka dretva na nekom procesoru završi s radom (ili nije više pripravna) ako prva u redu pripravnih na tom procesoru ima manji prioritet od prve u redu pripravnih nekog drugog procesora treba takvu dretvu većeg prioriteta POVUĆI iz tog reda i nju izvoditi. (procesor sam POVLAČI)
	Kad se jedna dretva ili više njih odblokira na jednom procesoru ako imaju veći prioritet od drugih trenutno aktivnih dretvi na tom ili drugim procesorima treba GURNUTI  odgovarajućim procesorima, tako da u svakom trenutku medu svim pripravnim dretvama, aktivne dretve budu one najvećeg prioriteta (dretva se GURA nekom procesoru)
4. Kada se kod nekritičnih dretvi neke prebacuju iz jednog reda pripravnih u drugi (drugog procesora)?
	Onda kada je potrebno uravnotežiti opterećenje procesore – balansirati redove pripravnih dretvi da sve ravnopravno dobiju procesorsko vrijeme.


****10. Primjeri iz implementacije raspoređivanja u Linuxu****


1. Navesti klase raspoređivača u Linuxu namijenjene za korisničke dretve.
	STOP – interni, koristi se pri micanju svih zadataka s nekog procesora
	DEADLINE - raspoređivanje vremenski kritičnih zadataka, prema kriteriju najbližeg krajnjeg trenutka završetka (klasa SCHED_DEADLINE)
	REALTIME – prioritetno raspoređivanje vremenski kritičnih zadataka (klase SCHED_FIFO i SCHED_RR)
	CFS - raspoređivanje normalnih zadataka podjelom vremena
	IDLE - kad nema drugih zadataka, onda se koriste ovi jezgrini
2. Koja struktura podataka se koristi za ostvarenje “reda pripravnih dretvi” kod CFS-a?
	crveno crna stabla

3. Što je to grupa zadataka (task_group) u kontekstu CFS-a?
	To je grupa zadataka koji su na neki način povezani (zadaci istog procesa) radi optimiranja u nekom višejezgrenom, višeprocesorskom ili NUMA sustavu
4. Koja je osnovna zamisao u korištenju procesorskih domena (engl. scheduling domains)?
	Osnovna zamisao korištenja je uzimanje u obzir heterogenosti procesore gdje svaka domena sadrži skup procesora nekih zajedničkih svojstava te svaka domena ima jednu ili više grupa zadataka koje se raspoređuju nad pripravnim procesorima, te se za svaku domenu definiraju određena pravila kojima se nastoji iskoristiti svojstva tih procesora


